#!/usr/bin/env bash

git-sync() {
    # Add, commit, push functions and aliases.
    # Hopefully safely
    
    local repo="${HOME}/gits/bashrc_stuff"

    # move to working dir 
    [[ "$(pwd)" != "$repo" ]] && pushd "$repo" >/dev/null 2>&1

    # ensure stash is clean
    [[ -n "$(git stash list)" ]] && git stash drop

    # stash changes (if any) & sync with github repo
    git stash >/dev/null 2>&1
    git pull

    # apply stash (if any)
    [[ -n "$(git stash list)" ]] && git stash apply

    # Add all, commit, push
    git add -A
    git commit -m "auto commited on: $(date -I'ns')"
    git push origin master

    # Good push? Drop the stash
    [[ "$?" -eq 0 ]] && git stash drop

    # Return to origin dir
    popd >/dev/null 2>&1

    # Source updated .bashrc
    unalias -a && . ${HOME}/.bashrc
}

spectre() {
    # Modified spectre wrapper
    _copy() {
        _clips=('pbcopy' 'xclip' 'gpaste-client')
        _use="${_clips[2]}"

        case "$_use" in
            "${_clips[0]}")
                hash "$_use" 2>/dev/null && "$_use" ;;
            "${_clips[1]}")
                hash "$_use" 2>/dev/null && "$_use" ;;
            "${_clips[2]}")
                hash "$_use" 2>/dev/null && "$_use" add-password "" ;;
            *)
                cat; echo 2>/dev/null
                return
        esac

        echo >&2 "Copied!"
    }

    if [[ "$1" =~ (-h|--help) ]]; then
	      # Call the binary directly when passing help flag so we
	      # don't get ugly output and duplicate output with pager
	      [[ ! -f /tmp/spectre_help ]] && ${HOME}/bin/spectre -h > /tmp/spectre_help 2>&1
	      
	      less /tmp/spectre_help
    else
 	      # Empty the clipboard.
	      :| _copy 2>/dev/null

	      # Ask for the user's name and password if not yet known.
	      SPECTRE_FULLNAME=${SPECTRE_USERNAME:-$(ask 'Your Full Name:')}

	      # restart the gpaste-client daemon  because it has
	      # trouble keeping up with clipboard changes.
	      gpaste-client daemon-reexec >/dev/null 2>&1
        
	      # Start Master Password and copy the output. This is where the
	      # magic begins.
	      printf %s "$(SPECTRE_USERNAME=$SPECTRE_USERNAME command spectre -F n "$@")" | _copy

	      # For gpaste-client: clear last password after 30 seconds
	      if [[ "$_use" = "${_clips[2]}" ]]; then
            (
                {
                    _name="spectre_$(mktemp -u XXXXXXXXXXXX)"
                    gpaste-client rename-password "" "$_name"
                    sleep 30
                    gpaste-client delete-password "$_name"
                } >/dev/null 2>&1 &
            )
	      fi
    fi
}

clip() {
    # syntactic sugar for gpaste-client
    gpaste="/usr/bin/gpaste-client"
    
    if [[ $1 =~ -e|--empty|-c|--clear ]]; then
        "$gpaste" empty
    else        
        "$gpaste"
    fi
}

debug() {
    # naive debug function
    set -x; "$@"; set +x
}

mpv() {
    # call mpv on a file and keep the display from sleeping
    local optimus="$(lspci | grep -E 'VGA|3D' | grep -E '[nN]vidia|NVIDIA')"
    
    play() {
	      # if nvidia optimus graphics card exists, use it
	      inhibit-and-play() {
	          # syntactic sugar
	          systemd-inhibit --what=handle-lid-switch /usr/bin/mpv "$@"
	      }
	      
	      if [[ -z "$optimus" ]]; then
	          inhibit-and-play "$@"
	      else
	          DRI_PRIME=1 inhibit-and-play "$@"
	      fi
    }
    
    play "$@" 
}

emacsctl() {
    # syntactic sugar for controlling emacs daemon.
    usage() {
	      printf "%s\n" "Usage: emacsctl {status|start|stop|restart|reload}"
    }
    
    case "$1" in
	      status|stop|start|restart)
	          systemctl --user "$1" emacs ;;
	      reload)
	          emacsctl restart ;;
	      *)
	          usage
    esac
}

mkrnd() {
    # generate a 64 character random password
    input="${@:-$(</dev/stdin)}"
    rnd="$(mktemp -u "$(for ((i=${input:-$1};i<${input:-$2};i++)); do printf "%s" "X"; done)")"
    
    printf "%s" "$rnd" | tee | gpaste-client
    printf "%s\n" "Random string copied to clipboard"
}

mmtail() {
    # pass arbitrary number of files to multitail or
    # all files in a directory
    mt() {
	      declare -a file
        
	      for object in "$@"; do
	          if [[ -f "$file" ]]; then
                files+=("$file ")
            fi
        done

	      multitail "${objects[@]}"
    }

    # if called w/o args, process all files; otherwise
    # process specified files
    if [[ -z "$@" ]]; then
        mt *
    else
        mt "$@"
    fi
}

miotop() {
    # pass arbitrary amount of PIDs to iotop
    for pid in $(pgrep "$1"); do
	      pids+=( "--pid $pid " )
    done

    sudo iotop "${pids[@]}"
}

vmanage() {
    # syntactic sugar for the
    # virtual box admin tool
    /usr/bin/vboxmanage "$@"
}

vterm_printf() {
    if [ -n "$TMUX" ] && ([ "${TERM%%-*}" = "tmux" ] || [ "${TERM%%-*}" = "screen" ]); then
        # Tell tmux to pass the escape sequences through
        printf "\ePtmux;\e\e]%s\007\e\\" "$1"
    elif [ "${TERM%%-*}" = "screen" ]; then
        # GNU screen (screen, screen-256color, screen-256color-bce)
        printf "\eP\e]%s\007\e\\" "$1"
    else
        printf "\e]%s\e\\" "$1"
    fi
}

dnf() {
    # run dnf from a layered package or
    # from a container
    distro=fedora
    release="$(uname -r | awk -F'.' '{print $(NF -1)}' | sed 's:fc::')"
    
    if [[ -e /usr/bin/dnf ]]; then
        /usr/bin/dnf $(echo $@)
    else
        podman run --rm "$distro":"$release" dnf $@
    fi
}

gnome-tweaks() {
    # run gnome-tweaks from a toolbox container, or
    # create the toolbox, install gnome-tweaks, and
    # run it.
    #
    # In either case update the container before
    # running gnome-tweaks
    distro=fedora
    release="$(uname -r | awk -F'.' '{print $(NF -1)}' | sed 's:fc::')"
    name=\gnome-tweaks
    
    if ! toolbox list | /usr/bin/grep -q gnome-tweaks; then
        (
            {
                toolbox --distro "$distro" --release  "$release" create "$name" &&
                    toolbox --container "$name" run \
                            sudo su -c "dnf upgrade -yq && dnf install -yq gnome-tweaks" &&
                    toolbox --container "$name" run "$name"
                podman kill "$name"
            } >/dev/null 2>&1 &
        )
    else
        (
            {
                toolbox --container "$name" run sudo dnf upgrade -yq &&
                    toolbox --container "$name" run "$name"
                podman kill "$name"
            } >/dev/null 2>&1 &
        ) 
    fi              
}

cpu-profiles() {
    # Get, set, or show current cpu scalings
    arg="$1"

    case "$arg" in
        performance|powersave)
            # set scaling
            sudo su -c "echo "$arg" | tee cat /sys/devices/system/cpu/cpu[0-9]*/cpufreq/scaling_governor" ;;
        --available|-a)
            # show available scalings
            cat /sys/devices/system/cpu/cpufreq/policy6/scaling_available_governors ;;
        --help|-h)

            cat <<EOF
Print or modifies the current cpu governor profile
            
Useage: cpu_profiles [performance|powersave|--available|-a|--help|-h]
            
    --available|available         lists the available profiles
    --help|help                   prints this help message
            
Passing no argument prints the current profile
EOF
            ;;
        *)
            # Get currnet scalings per cpu and pretty print them on one line
            scalingc=( $(cat /sys/devices/system/cpu/cpu[0-9]*/cpufreq/scaling_governor) )
            scalingp+=()
            
            for scaling in ${scalingc[@]}; do
                scalingp+="$scaling "
            done
            
            echo "${scalingp[@]}"

            # protects agains accumulating more values
            # beyond the number of cpu cores if being
            # called in a compound command
            scalingp=
    esac
}

cpu-temps() {
    # Show cpu temps in degrees F, and them print on a single line
    tempm=( $(cat /sys/class/thermal/thermal_zone[0-9]*/temp) )
    tempf=()
    
    for temp in ${tempm[@]}; do
        tempf+="$((($temp / 1000) * 9/5 + 32))F "
    done

    echo ${tempf[@]}

    # protects agains accumulating more values
    # beyond the number of cpu cores if being
    # called in a compound command
    tempm=
}

search() {
    # simple search with firefox and searx.
    # starts firefox with the search query,
    # or creates a new tab in the existing
    # instance
    baseurl="https://searx.be/search?preferences="
    preferences="$(cat $HOME/gits/bashrc_stuff/env/searx-be-preferences)"
    query="&q=$*"
    range="&time_rage=year"

    if ps -e | grep -q GeckoMain; then
        (
            {
                /usr/bin/firefox --new-tab "${baseurl}${preferences}${query}${range}"
            } >/dev/null 2>&1 &
        )
    else
        (
            {
                /usr/bin/firefox --new-instance "${baseurl}${preferences}${query}${range}"
            } >/dev/null 2>&1 &
        )
    fi
}

decode64() {
    # decodes a base64 input string
    bpath="$PWD"
    fname="decoded-$(mktemp -u $(for i in {0..15}; do printf X; done))"
    fpath="$bpath/$fname"
    # ${input} allows the following or equvalent:
    # $ cat file | decode64 -
    # $ decode64 < <(cat file)
    # $ decode64 $(cat file)
    input="${@:-$(</dev/stdin)}"

    if echo "$input" | base64 -d --ignore-garbage - >/dev/null 2>&1; then
        # this does most of the work
        extension="$(echo $input | base64 -d --ignore-garbage - | tee "$fpath" | file --brief --extension -)"
        
        if [[ -s $fpath ]]; then
            success="File written to ${fpath}.${extension}"
            mv "$fpath" "${fpath}.${extension}"
            echo "$success"
        else
            rm "$fpath"
            echo "Input is empty."
        fi
    else
        echo "Input is garbage."
    fi
}

psgrep() {
    # print bsd style processes of
    # of the given input string
    ps aux | grep -v grep | grep "$@"
}

which() {
    input="$@"
    # correctly calls which, but don't know why yet :shrug:
    /usr/bin/which --tty-only \
                   --read-alias \
                   --read-functions \
                   --show-tilde \
                   --show-dot "$input" < <(alias; declare -f)
}

edit() {
    # edit a file in users HOME directory
    # general casse is for bash config files
    file=".$1"
    
    if [[ -f $HOME/${file} ]]; then
        emacs $HOME/${file}
    else
        printf "%s\n" "File, $file, not found in $HOME."
    fi
}

emacs() {
    # connect to the local emacs daemon if non-privleged;
    # or run a standalone terminal session of emacs
    input="$@"    
    alias enox="/usr/bin/emacs-nox"
    alias eclt="/usr/bin/emacsclient -nw"

    if [[ $UID = 0 ]] || [[ $EUID = 0 ]]; then
        [[ -z "$input" ]] && enox || enox "$input"
    else
        [[ -z "$input" ]] && eclt || eclt "$input"
    fi
}
